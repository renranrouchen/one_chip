C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MYDEMO
OBJECT MODULE PLACED IN .\out\MyDemo.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MyDemo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\MyDemo
                    -.lst) TABS(2) OBJECT(.\out\MyDemo.obj)

line level    source

   1          
   2          #include "MyConfig.h"
   3          #include "MyDemo.h"
   4          #include <intrins.h>
   5          
   6          
   7          #if CONFIG_UTRL == ENABLED
   8          
   9          void DelayMs_utrl(unsigned int time)
  10          {
  11   1        unsigned int i,j;
  12   1        for(i=0;i<time;i++)
  13   1          for(j=0;j<112;j++);
  14   1      }
  15          
  16          #endif
  17          /*********************LCD1602*********************/
  18          #if CONFIG_UART0 == ENABLED
  19          bit UART0_TXD_BUSY = 0;
  20          uchar xdata rev_start = 0;     //接收开始标志
  21          uchar xdata rev_stop  = 0;     //接收停止标志
  22          #include <string.h>
  23          uchar xdata num = 0;           //
  24          uchar xdata gps_flag = 0;      //GPS处理标志
  25          char  xdata rev_buf[80];        //接收缓存
  26          
  27          void UART0_Send_Byte_Demo(unsigned char a)
  28          {
  29   1      
  30   1        SBUF = a;
  31   1        UART0_TXD_BUSY = 1; 
  32   1        while(UART0_TXD_BUSY);  //等待发送成功
  33   1      
  34   1      }
  35          
  36          char putchar(char c)
  37          {
  38   1        UART0_Send_Byte_Demo(c);
  39   1        return c;
  40   1      }
  41          
  42          
  43          /*----------------------------
  44          UART1 发送字符串
  45          -----------------------------*/
  46          void UART0_Send_String_Demo(char *s)
  47          {
  48   1        while(*s)//检测字符串结束符
  49   1        {
  50   2          UART0_Send_Byte_Demo(*s++);//发送当前字符
  51   2        }
  52   1      }
  53          
  54          
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 2   

  55          void UART0_Init_Demo()
  56          {
  57   1        
  58   1        TMOD|= 0X20;    //T1  方式2  ，8位   自动重装   
  59   1        TH1=0Xfd;
  60   1        TL1=0Xfd;     //9600
  61   1        TR1=1;        // 定时器1启动  
  62   1      
  63   1      
  64   1        SM0=0;      // 设置串口的工作模式
  65   1        SM1=1;      //方式1
  66   1      
  67   1      
  68   1        REN=1;     // 允许串口接收数据   
  69   1      
  70   1        TI=1;
  71   1        ES=1;        // 串口中断应许 
  72   1        EA=1;    // 开启中断 
  73   1      
  74   1        
  75   1      }
  76          
  77          void UART0_ISR(void) interrupt 4
  78          {
  79   1        uchar ch;
  80   1        
  81   1        if(RI)
  82   1        {
  83   2          RI = 0;
  84   2          
  85   2          ch = SBUF;
  86   2          if ((ch == '$') && (gps_flag == 0))  //如果收到字符'$'，便开始接收
  87   2          {
  88   3            rev_start = 1;
  89   3            rev_stop  = 0;
  90   3          }
  91   2        
  92   2          if (rev_start == 1)  //标志位为1，开始接收
  93   2          {
  94   3            rev_buf[num++] = ch;  //字符存到数组中
  95   3            if (ch == '\n')     //如果接收到换行
  96   3            {
  97   4              rev_buf[num] = '\0';
  98   4              rev_start = 0;
  99   4              rev_stop  = 1;
 100   4              gps_flag = 1;
 101   4              num = 0;
 102   4            }
 103   3          }     
 104   2            
 105   2        }
 106   1        else if(TI)
 107   1        {
 108   2          TI = 0;
 109   2          UART0_TXD_BUSY = 0;
 110   2        }
 111   1        else
 112   1        {
 113   2          RI = 0;
 114   2          TI = 0;
 115   2        }
 116   1        
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 3   

 117   1      }
 118          static uchar GetComma(uchar num,char *str)
 119          {
 120   1        uchar i,j = 0;
 121   1        int len=strlen(str);
 122   1      
 123   1        for(i = 0;i < len;i ++)
 124   1        {
 125   2          if(str[i] == ',')
 126   2            j++;
 127   2          if(j == num)
 128   2            return i + 1; 
 129   2        }
 130   1      
 131   1        return 0; 
 132   1      }
 133          
 134          
 135          static float Str_To_Float(char *buf)
 136          {
 137   1        float rev = 0;
 138   1        float dat;
 139   1        int integer = 1;
 140   1        char *str = buf;
 141   1        int i;
 142   1        while(*str != '\0')
 143   1        {
 144   2          switch(*str)
 145   2          {
 146   3            case '0':
 147   3              dat = 0;
 148   3              break;
 149   3            case '1':
 150   3              dat = 1;
 151   3              break;
 152   3            case '2':
 153   3              dat = 2;
 154   3              break;    
 155   3            case '3':
 156   3              dat = 3;
 157   3              break;
 158   3            case '4':
 159   3              dat = 4;
 160   3              break;
 161   3            case '5':
 162   3              dat = 5;
 163   3              break;
 164   3            case '6':
 165   3              dat = 6;
 166   3              break;
 167   3            case '7':
 168   3              dat = 7;
 169   3              break;
 170   3            case '8':
 171   3              dat = 8;
 172   3              break;
 173   3            case '9':
 174   3              dat = 9;
 175   3              break;
 176   3            case '.':
 177   3              dat = '.';
 178   3              break;
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 4   

 179   3          }
 180   2          if(dat == '.')
 181   2          {
 182   3            integer = 0;
 183   3            i = 1;
 184   3            str ++;
 185   3            continue;
 186   3          }
 187   2          if( integer == 1 )
 188   2          {
 189   3            rev = rev * 10 + dat;
 190   3          }
 191   2          else
 192   2          {
 193   3            rev = rev + dat / (10 * i);
 194   3            i = i * 10 ;
 195   3          }
 196   2          str ++;
 197   2        }
 198   1        return rev;
 199   1      
 200   1      }
 201                                  
 202          
 203          static float Get_Float_Number(char *s)
 204          {
 205   1        char xdata buf[10];
 206   1        uchar i;
 207   1        float rev;
 208   1        i=GetComma(1, s);
 209   1        i = i - 1;
 210   1        strncpy(buf, s, i);
 211   1        buf[i] = 0;
 212   1        rev=Str_To_Float(buf);
 213   1        return rev; 
 214   1      }
 215          
 216          
 217          static double Str_To_Double(char *buf)
 218          {
 219   1        double rev = 0;
 220   1        double dat;
 221   1        int integer = 1;
 222   1        char *str = buf;
 223   1        int i;
 224   1        while(*str != '\0')
 225   1        {
 226   2          switch(*str)
 227   2          {
 228   3            case '0':
 229   3              dat = 0;
 230   3              break;
 231   3            case '1':
 232   3              dat = 1;
 233   3              break;
 234   3            case '2':
 235   3              dat = 2;
 236   3              break;    
 237   3            case '3':
 238   3              dat = 3;
 239   3              break;
 240   3            case '4':
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 5   

 241   3              dat = 4;
 242   3              break;
 243   3            case '5':
 244   3              dat = 5;
 245   3              break;
 246   3            case '6':
 247   3              dat = 6;
 248   3              break;
 249   3            case '7':
 250   3              dat = 7;
 251   3              break;
 252   3            case '8':
 253   3              dat = 8;
 254   3              break;
 255   3            case '9':
 256   3              dat = 9;
 257   3              break;
 258   3            case '.':
 259   3              dat = '.';
 260   3              break;
 261   3          }
 262   2          if(dat == '.')
 263   2          {
 264   3            integer = 0;
 265   3            i = 1;
 266   3            str ++;
 267   3            continue;
 268   3          }
 269   2          if( integer == 1 )
 270   2          {
 271   3            rev = rev * 10 + dat;
 272   3          }
 273   2          else
 274   2          {
 275   3            rev = rev + dat / (10 * i);
 276   3            i = i * 10 ;
 277   3          }
 278   2          str ++;
 279   2        }
 280   1        return rev;
 281   1      }
 282                                  
 283          
 284          static double Get_Double_Number(char *s)
 285          {
 286   1        char xdata buf[10];
 287   1        uchar i;
 288   1        double rev;
 289   1        i=GetComma(1, s);
 290   1        i = i - 1;
 291   1        strncpy(buf, s, i);
 292   1        buf[i] = 0;
 293   1        rev=Str_To_Double(buf);
 294   1        return rev; 
 295   1      }
 296          
 297          
 298          
 299          
 300          
 301          static void UTC2BTC(DATE_TIME *GPS)
 302          {
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 6   

 303   1        GPS->second ++;  
 304   1        if(GPS->second > 59)
 305   1        {
 306   2          GPS->second = 0;
 307   2          GPS->minute ++;
 308   2          if(GPS->minute > 59)
 309   2          {
 310   3            GPS->minute = 0;
 311   3            GPS->hour ++;
 312   3          }
 313   2        } 
 314   1      
 315   1          GPS->hour = GPS->hour + 8;
 316   1        if(GPS->hour > 23)
 317   1        {
 318   2          GPS->hour -= 24;
 319   2          GPS->day += 1;
 320   2          if(GPS->month == 2 ||
 321   2                GPS->month == 4 ||
 322   2                GPS->month == 6 ||
 323   2                GPS->month == 9 ||
 324   2                GPS->month == 11 )
 325   2          {
 326   3            if(GPS->day > 30)
 327   3            {
 328   4                GPS->day = 1;
 329   4              GPS->month++;
 330   4            }
 331   3          }
 332   2          else
 333   2          {
 334   3            if(GPS->day > 31)
 335   3            { 
 336   4                GPS->day = 1;
 337   4              GPS->month ++;
 338   4            }
 339   3          }
 340   2          if(GPS->year % 4 == 0 )
 341   2          {
 342   3              if(GPS->day > 29 && GPS->month == 2)
 343   3            {   
 344   4                GPS->day = 1;
 345   4              GPS->month ++;
 346   4            }
 347   3          }
 348   2          else
 349   2          {
 350   3              if(GPS->day > 28 &&GPS->month == 2)
 351   3            {
 352   4                GPS->day = 1;
 353   4              GPS->month ++;
 354   4            }
 355   3          }
 356   2          if(GPS->month > 12)
 357   2          {
 358   3            GPS->month -= 12;
 359   3            GPS->year ++;
 360   3          }   
 361   2        }
 362   1      }
 363          
 364          void Int_To_Str(int x,char *Str)
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 7   

 365          {
 366   1        int t;
 367   1        char *Ptr,Buf[5];
 368   1        int i = 0;
 369   1        Ptr = Str;
 370   1        if(x < 10)    // 当整数小于10时,转化为"0x"的格式
 371   1        {
 372   2          *Ptr ++ = '0';
 373   2          *Ptr ++ = x+0x30;
 374   2        }
 375   1        else
 376   1        {
 377   2          while(x > 0)
 378   2          {
 379   3            t = x % 10;
 380   3            x = x / 10;
 381   3            Buf[i++] = t+0x30;  // 通过计算把数字转化成ASCII码形式
 382   3          }
 383   2          i -- ;
 384   2          for(;i >= 0;i --)     // 将得到的字符串倒序
 385   2          {
 386   3            *(Ptr++) = Buf[i];
 387   3          }
 388   2        }
 389   1        *Ptr = '\0';
 390   1      }
 391          //$GPGGA,043006.00,2244.5931794,N,11432.9395981,E,15,19,0.4,16.6771,M,-1.530,M,18.0,0000*5E
 392          int GPS_GGA_Parse(char *line,GPS_INFO *GPS)
 393          {
 394   1        uchar ch, status;
 395   1        char *loact;
 396   1        char *buf = line;
 397   1        ch = buf[4];
 398   1        
 399   1        status = buf[GetComma(2, buf)];
 400   1        
 401   1        if (ch == 'G')  //$GPGGA
 402   1        {
 403   2          if (status != ',')
 404   2          {
 405   3            loact = &buf[GetComma(2, buf)];
 406   3            GPS->la_arry[0]=loact[0];
 407   3            GPS->la_arry[1]=loact[1];
 408   3            GPS->la_arry[2]='$';
 409   3            GPS->la_arry[3]=loact[2];
 410   3            GPS->la_arry[4]=loact[3];
 411   3            GPS->la_arry[5]=loact[4];
 412   3            GPS->la_arry[6]=loact[5];
 413   3            GPS->la_arry[7]=loact[6];
 414   3            GPS->la_arry[8]=loact[7];
 415   3            GPS->la_arry[9]=0;
 416   3            
 417   3            loact = &buf[GetComma(4, buf)];
 418   3            GPS->lo_arry[0]=loact[0];
 419   3            GPS->lo_arry[1]=loact[1];
 420   3            GPS->lo_arry[2]=loact[2];
 421   3            GPS->lo_arry[3]='$';
 422   3            GPS->lo_arry[4]=loact[3];
 423   3            GPS->lo_arry[5]=loact[4];
 424   3            GPS->lo_arry[6]=loact[5];
 425   3            GPS->lo_arry[7]=loact[6];
 426   3            GPS->lo_arry[8]=loact[7];
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 8   

 427   3            GPS->lo_arry[9]=0;      
 428   3            
 429   3            GPS->longitude  = Get_Double_Number(&buf[GetComma(2, buf)]);
 430   3            GPS->latitude  = Get_Double_Number(&buf[GetComma( 4, buf)]);
 431   3            GPS->speed=Get_Double_Number(&buf[GetComma(6, buf)]);      
 432   3            GPS->direction=Get_Double_Number(&buf[GetComma(7, buf)]); 
 433   3            return 1;
 434   3          }
 435   2        }
 436   1        
 437   1        return 0;
 438   1      }
 439              
 440          #endif
 441          
 442          
 443          
 444          /********************KEY_MAP *********************/
 445          #if CONFIG_LCD12864_PLUS== ENABLED
 446          
 447          
 448          #if CONFIG_CH == ENABLED
 449          unsigned char code zm8x16_index[]="0123456789: |-+.<$";//字串索引
 450          unsigned char code zm8x16_Table[][16]={
 451            0xF8,0xFC,0x04,0xC4,0x24,0xFC,0xF8,0x00,0x07,0x0F,0x09,0x08,0x08,0x0F,0x07,0x00, // -0-
 452            //0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,
 453            0x00,0x10,0x18,0xFC,0xFC,0x00,0x00,0x00,0x00,0x08,0x08,0x0F,0x0F,0x08,0x08,0x00, // -1-
 454            0x08,0x0C,0x84,0xC4,0x64,0x3C,0x18,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0C,0x00, // -2-
 455            0x08,0x0C,0x44,0x44,0x44,0xFC,0xB8,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00, // -3-
 456            0xC0,0xE0,0xB0,0x98,0xFC,0xFC,0x80,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00, // -4-
 457            0x7C,0x7C,0x44,0x44,0xC4,0xC4,0x84,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00, // -5-
 458            0xF0,0xF8,0x4C,0x44,0x44,0xC0,0x80,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -6-
 459            0x0C,0x0C,0x04,0x84,0xC4,0x7C,0x3C,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00, // -7-
 460            0xB8,0xFC,0x44,0x44,0x44,0xFC,0xB8,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -8-
 461            0x38,0x7C,0x44,0x44,0x44,0xFC,0xF8,0x00,0x00,0x08,0x08,0x08,0x0C,0x07,0x03,0x00, // -9-
 462            0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00, // -:-
 463            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // - -
 464            0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00, // -|-
 465            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01, // ---
 466            0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0xFF,0x01,0x01,0x01, // -+-
 467            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,/*".",0*/ 
 468            0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,/*"<",0*/
 469            0x00,0x00,0x0C,0x12,0x12,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 470          };
 471          #else
              unsigned char code zm8x16_index[]="0123456789: |-+.<abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
             -//字串索引
              unsigned char code zm8x16_Table[][16]={
                0xF8,0xFC,0x04,0xC4,0x24,0xFC,0xF8,0x00,0x07,0x0F,0x09,0x08,0x08,0x0F,0x07,0x00, // -0-
                //0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,
                0x00,0x10,0x18,0xFC,0xFC,0x00,0x00,0x00,0x00,0x08,0x08,0x0F,0x0F,0x08,0x08,0x00, // -1-
                0x08,0x0C,0x84,0xC4,0x64,0x3C,0x18,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0C,0x00, // -2-
                0x08,0x0C,0x44,0x44,0x44,0xFC,0xB8,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00, // -3-
                0xC0,0xE0,0xB0,0x98,0xFC,0xFC,0x80,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00, // -4-
                0x7C,0x7C,0x44,0x44,0xC4,0xC4,0x84,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00, // -5-
                0xF0,0xF8,0x4C,0x44,0x44,0xC0,0x80,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -6-
                0x0C,0x0C,0x04,0x84,0xC4,0x7C,0x3C,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00, // -7-
                0xB8,0xFC,0x44,0x44,0x44,0xFC,0xB8,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -8-
                0x38,0x7C,0x44,0x44,0x44,0xFC,0xF8,0x00,0x00,0x08,0x08,0x08,0x0C,0x07,0x03,0x00, // -9-
                0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00, // -:-
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // - -
                0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00, // -|-
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 9   

                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01, // ---
                0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0xFF,0x01,0x01,0x01, // -+-
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,/*".",0*/ 
                0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,/*"<",0*/ 
              0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x19,0x24,0x24,0x12,0x3F,0x20,0x00,/*"a",0*/
              0x10,0xF0,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,/*"b",1*/
              0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,/*"c",2*/
              0x00,0x00,0x80,0x80,0x80,0x90,0xF0,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,/*"d",3*/
              0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00,/*"e",4*/
              0x00,0x80,0x80,0xE0,0x90,0x90,0x20,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,/*"f",5*/
              0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,/*"g",6*/
              0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,/*"h",7*/
              0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,/*"i",8*/
              0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,/*"j",0*/
              0x10,0xF0,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x06,0x29,0x30,0x20,0x00,/*"k",10*/
              0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,/*"l",11*/
              0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,/*"m",12*/
              0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,/*"n",13*/
              0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,/*"o",14*/
              0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00,/*"p",15*/
              0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0x91,0xFF,0x80,/*"q",16*/
              0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,/*"r",17*/
              0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,/*"s",18*/
              0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x10,0x00,/*"t",19*/
              0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,/*"u",20*/
              0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x03,0x0C,0x30,0x0C,0x03,0x00,0x00,/*"v",21*/
              0x80,0x80,0x00,0x80,0x80,0x00,0x80,0x80,0x01,0x0E,0x30,0x0C,0x07,0x38,0x06,0x01,/*"w",22*/
              0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x20,0x31,0x0E,0x2E,0x31,0x20,0x00,/*"x",23*/
              0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00,/*"y",24*/
              0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,/*"z",25*/
              0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,/*"A",26*/
              0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,/*"B",27*/
              0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,/*"C",28*/
              0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,/*"D",29*/
              0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,/*"E",30*/
              0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,/*"F",31*/
              0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,/*"G",32*/
              0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,/*"H",33*/
              0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,/*"I",34*/
              0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,/*"J",0*/
              0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,/*"K",36*/
              0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,/*"L",37*/
              0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00,/*"M",38*/
              0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,/*"N",39*/
              0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,/*"O",40*/
              0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,/*"P",41*/
              0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00,/*"Q",42*/
              0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,/*"R",43*/
              0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,/*"S",44*/
              0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,/*"T",45*/
              0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,/*"U",46*/
              0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,/*"V",47*/
              0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00,/*"W",48*/
              0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,/*"X",49*/
              0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,/*"Y",50*/
              0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,/*"Z",51*/
              };
              #endif
 546          unsigned char code zm16x16_index[]="卫星值经纬度固定解未收敛";//字串索引
 547          unsigned char code zm16x16_Table[][32]={
 548          
 549          0x00,0x02,0x02,0x02,0x02,0x02,0xFE,0x02,0x02,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 10  

 550          0x40,0x40,0x40,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,0x41,0x42,0x41,0x40,0x40,0x00,/*"?",0*/
 551          
 552          0x00,0x00,0x00,0xBE,0x2A,0x2A,0x2A,0xEA,0x2A,0x2A,0x2A,0x3E,0x00,0x00,0x00,0x00,
 553          0x00,0x44,0x42,0x49,0x49,0x49,0x49,0x7F,0x49,0x49,0x49,0x49,0x41,0x40,0x00,0x00,/*"?",1*/
 554          
 555          0x90,0x52,0x34,0x10,0xFF,0x10,0x34,0x52,0x80,0x70,0x8F,0x08,0x08,0xF8,0x08,0x00,
 556          0x82,0x9A,0x56,0x63,0x22,0x52,0x8E,0x00,0x80,0x40,0x33,0x0C,0x33,0x40,0x80,0x00,/*"?",2*/
 557          
 558          0x20,0x30,0xAC,0x63,0x20,0x18,0x80,0x82,0x42,0x22,0x12,0x1A,0x26,0x42,0x80,0x00,
 559          0x22,0x67,0x22,0x12,0x12,0x12,0x40,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x40,0x00,/*"?",3*/
 560          
 561          0x20,0x30,0xAC,0x63,0x20,0x18,0x00,0x08,0x48,0x48,0xFF,0x48,0x48,0x48,0x08,0x00,
 562          0x22,0x67,0x22,0x12,0x12,0x12,0x00,0x02,0x02,0x02,0xFF,0x02,0x12,0x22,0x1E,0x00,/*"?",4*/
 563          
 564          0x00,0x00,0xFC,0x24,0x24,0x24,0xFC,0x25,0x26,0x24,0xFC,0x24,0x24,0x24,0x04,0x00,
 565          0x40,0x30,0x8F,0x80,0x84,0x4C,0x55,0x25,0x25,0x25,0x55,0x4C,0x80,0x80,0x80,0x00,/*"?",5*/
 566          
 567          0x00,0xFE,0x02,0x12,0x92,0x92,0x92,0xFE,0x92,0x92,0x92,0x12,0x02,0xFE,0x00,0x00,
 568          0x00,0xFF,0x40,0x40,0x5F,0x48,0x48,0x48,0x48,0x48,0x5F,0x40,0x40,0xFF,0x00,0x00,/*"?",6*/
 569          
 570          0x10,0x0C,0x44,0x44,0x44,0x44,0x45,0xC6,0x44,0x44,0x44,0x44,0x44,0x14,0x0C,0x00,
 571          0x80,0x40,0x20,0x1E,0x20,0x40,0x40,0x7F,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00,/*"?",7*/
 572          
 573          0x20,0x10,0xEC,0x27,0xF4,0x2C,0xE0,0x00,0x22,0x92,0x0E,0xD2,0x22,0x1E,0x00,0x00,
 574          0x80,0x60,0x1F,0x09,0x3F,0x89,0xFF,0x00,0x0A,0x09,0x09,0xFF,0x09,0x09,0x08,0x00,/*"?",8*/
 575          
 576          0x80,0x80,0x88,0x88,0x88,0x88,0x88,0xFF,0x88,0x88,0x88,0x88,0x88,0x80,0x80,0x00,
 577          0x20,0x20,0x10,0x08,0x04,0x02,0x01,0xFF,0x01,0x02,0x04,0x08,0x10,0x20,0x20,0x00,/*"?",9*/
 578          
 579          0x00,0xFC,0x00,0x00,0xFF,0x00,0x40,0x20,0xD8,0x17,0x10,0x10,0xF0,0x10,0x10,0x00,
 580          0x00,0x0F,0x04,0x02,0xFF,0x00,0x80,0x40,0x21,0x16,0x08,0x16,0x21,0x40,0x80,0x00,/*"?",10*/
 581          
 582          0x40,0x20,0x50,0x4C,0x43,0x44,0x48,0x10,0xA0,0x70,0x8F,0x08,0x08,0xF8,0x08,0x00,
 583          0x00,0x44,0xD8,0x41,0x46,0x20,0x38,0xA7,0x40,0x20,0x13,0x0C,0x33,0x40,0x80,0x00,/*"?",11*/
 584          
 585          
 586          
 587                
 588          };
 589          /** LCM忙检测 **/
 590          void busy12864(){
 591   1        lcdDat=0xff;    //口线置1，防止干扰
 592   1        rs=0; rw=1;    //置“命令、读”模式
 593   1        //en=1; while(lcdDat&0x80); en=0;//忙等待
 594   1      }
 595          /** 写命令 参数：comDat为要发送的命令 **/
 596          void WriteCom(unsigned char comDat){  
 597   1          busy12864();        //忙，则等待
 598   1        rs=0;rw=0;        //置“命令、写”模式
 599   1          lcdDat=comDat;en=1;en=0;//送出命令，并使之有效
 600   1      }
 601          /** 写数据 参数：dat为要发送的数据 **/
 602          void WriteDat(unsigned char dat){  
 603   1          busy12864();        //忙，则等待
 604   1        rs=1;rw=0;          //置“数据、写”模式
 605   1          lcdDat=dat;en=1;en=0; //送出数据，并使之有效
 606   1      }
 607          /** 初始化12864 **/
 608          void Init12864(){
 609   1        lcdDat=0xff;   //口线置1，防止干扰
 610   1        rs=0; rw=1;    //置“命令、读”模式
 611   1        //en=1; while(lcdDat&0x10); en=0;//等待复位完成
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 11  

 612   1        WriteCom(0x3f);   //开显示
 613   1        WriteCom(addZ0);    //设置显示起始行
 614   1      }
 615          
 616          /******** 任意尺寸点阵显示函数 ***********|
 617          |参数：显示位置：row页数，col列号，     |
 618          |    字符大小：x横向像素，y纵向页数   |
 619          |    显示内容：tab字模表          ******/
 620          void showXY(unsigned char row,unsigned char col,unsigned char x,unsigned char y,unsigned char *tab){
 621   1        unsigned char i,j;
 622   1        bit right;
 623   1        if(col<64){right=0;} //置左右屏标志
 624   1        else {col-=64;right=1;} 
 625   1        for(i=0;i<y;i++){
 626   2          if(right)cs2=0,cs1=1;
 627   2          else  cs2=1,cs1=0;
 628   2          WriteCom(addX0+row+i); //行
 629   2          WriteCom(addY0+col);   //列
 630   2          for(j=0;j<x;j++){
 631   3            if(col+j<64)WriteDat(tab[i*x+j]); //未跨屏
 632   3            else if(right==0){      //从左屏跨右屏
 633   4               cs2=0,cs1=1;     //选中右屏
 634   4               WriteCom(addX0+row+i);    //设置行
 635   4               WriteCom(addY0+(col+j-64));
 636   4               WriteDat(tab[i*x+j]);
 637   4            }            //在右屏越界不显示
 638   3          }
 639   2        }
 640   1      }
 641          
 642          /* 返回一个8*16字符索引位置 */          
 643          unsigned char enN(unsigned char *s){
 644   1        unsigned char i;
 645   1        for(i=0;zm8x16_index[i]!=0;i++)if(zm8x16_index[i]==s[0])break;
 646   1        return i; 
 647   1      }
 648          /* 返回一个16*16字符索引位置 */
 649          unsigned char cnN(unsigned char *s){
 650   1        unsigned char i;
 651   1        for(i=0;zm16x16_index[i]!=0;i+=2)
 652   1          if(zm16x16_index[i]==*s&&zm16x16_index[i+1]==*(s+1))break ;
 653   1        return i/2;
 654   1      }
 655          /* 显示中英文字符串 */
 656          void showStr(unsigned char row,unsigned char col,unsigned char *s){
 657   1         unsigned char i;
 658   1         for(i=0;s[i]!=0;i++){
 659   2          if(s[i]<0x80){  //英文
 660   3            showXY(row,col,8,2,zm8x16_Table[enN(&s[i])]);
 661   3            col+=8;
 662   3          }else{      
 663   3            showXY(row,col,16,2,zm16x16_Table[cnN(&s[i])]); 
 664   3            col+=16;i+=1;   
 665   3          }
 666   2          if(col>120){   //换行处理
 667   3            col=0;
 668   3            row+=2;
 669   3          }
 670   2         }
 671   1      }
 672          /* 显示数字 */
 673          void showNum(unsigned char row,unsigned char col,unsigned char s){
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 12  

 674   1        showXY(row,col,8,2,zm8x16_Table[s]);
 675   1      }
 676          void showThreeNum(unsigned char row,unsigned char col,unsigned int s)
 677          {
 678   1        showNum(row,col,s/100%10);
 679   1        showNum(row,col+8,s/10%10);
 680   1        showNum(row,col+16,s%10);
 681   1      }
 682          void showJIN(unsigned char row,unsigned char col,unsigned int s)
 683          {
 684   1        showNum(row,col,s/10000%10);
 685   1        showNum(row,col+8,s/1000%10);
 686   1        showNum(row,col+16,s/100%10);
 687   1        showStr(row,col+24,".");
 688   1        showNum(row,col+32,s/10%10);
 689   1        showNum(row,col+40,s%10);
 690   1      }
 691          void showwei(unsigned char row,unsigned char col,unsigned int s)
 692          {
 693   1        showNum(row,col,s/10000%10);
 694   1        showNum(row,col+8,s/1000%10);
 695   1        showStr(row,col+16,".");  
 696   1        showNum(row,col+24,s/1000%10);
 697   1        showNum(row,col+32,s/100%10);
 698   1        showStr(row,col+40,".");
 699   1        showNum(row,col+48,s/10%10);  
 700   1        showNum(row,col+56,s%10);
 701   1      }
 702          #if CONFIG_DS18b02 == ENABLED
              void showDS18B02Num(unsigned char row,unsigned char col,unsigned int s)
              {
                showNum(row,col,s/100%10);
                showNum(row,col+8,s/10%10);
                showStr(row,col+16,".");
                showNum(row,col+24,s%10);
              }
              #endif
 711          #if CONFIG_DS1302 == ENABLED
              void Ds13b02_DisPlay_12864(unsigned char row,unsigned char col,unsigned char shi,unsigned char fen,unsigne
             -d char miao)
              {
              
                showNum(row,col,shi%100/10);    // 十位
                showNum(row,col+8,shi%10);        // 个位
                showStr(row,col+8*2,":");
                showNum(row,col+8*3,fen%100/10);    // 十位
                showNum(row,col+8*4,fen%10);        // 个位
                showStr(row,col+8*5,":");
                showNum(row,col+8*6,miao%100/10);   // 十位
                showNum(row,col+8*7,miao%10);       // 个位
              
              }
              #endif
 726          #endif
 727          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3408    ----
   CONSTANT SIZE    =    718    ----
   XDATA SIZE       =     84      20
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   MYDEMO                                                                03/15/2024 14:26:12 PAGE 13  

   DATA SIZE        =   ----     105
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
