

#include "OLED.H"



#define Uchar unsigned char
#define Uint  unsigned int
#define Ulong unsigned long
#define uchar unsigned char
#define uint  unsigned int


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Pin Definition
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


//0.66bule








//OLED的显存
//存放格式如下.
//[0]0 1 2 3 ... 127	
//[1]0 1 2 3 ... 127	
//[2]0 1 2 3 ... 127	
//[3]0 1 2 3 ... 127	
//[4]0 1 2 3 ... 127	
//[5]0 1 2 3 ... 127	
//[6]0 1 2 3 ... 127	
//[7]0 1 2 3 ... 127 		   
unsigned char OLED_GRAM[128][8]={0};



////-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//void 	delay_ms(unsigned int t)
//{
//	Uchar i,j;
//	while(--t)
//	{
//	i=50;	
//	j=100;

//		while(--j)
//			while(--i);
//	}
//}


void uDelay(unsigned char l)
{
	while(l--);
}


void Delay(unsigned char n)
{
unsigned char i,j,k;

	for(k=0;k<n;k++)
	{
		for(i=0;i<131;i++)
		{
			for(j=0;j<15;j++)
			{
				uDelay(203);	
			}
		}
	}
}


//****************************************************************************
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Read/Write Sequence
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void I2C_3(unsigned char mcmd)
{
unsigned char length = 8;			// Send Command

	while(length--)
	{
		if(mcmd & 0x80)
		{
			SDA3_1;
		}
		else
		{
			SDA3_0;
		}
//		uDelay(3);
		SCL3_1;
//		uDelay(3);
		SCL3_0;
//		uDelay(3);
		mcmd = mcmd << 1;
	}
}


void I2C_Ack3()
{
	SDA3_1;
//	uDelay(3);
	SCL3_1;
//	uDelay(3);
	SCL3_0;
//	uDelay(3);
}


void I2C_NAck3()
{
	SDA3_0;
//	uDelay(3);
	SCL3_1;
//	uDelay(3);
	SCL3_0;
//	uDelay(3);
}


void I2C_Start3()
{
	SDA3_0;
//	uDelay(3);
	SCL3_1;
//	uDelay(3);
	SCL3_0;
//	uDelay(3);
	I2C_3(0x78);
	I2C_Ack3();
}


void I2C_Stop3()
{
	SCL3_1;
//	uDelay(5);
	SDA3_0;
//	uDelay(5);
	SDA3_1;
//	uDelay(5);
}


void Write_Command3(unsigned char Data)
{
	I2C_Start3();
	I2C_3(0x00);
	I2C_Ack3();
	I2C_3(Data);
	I2C_Ack3();
	I2C_Stop3();
}


void Write_Data3(unsigned char Data)
{
	I2C_Start3();
	I2C_3(0x40);
	I2C_Ack3();
	I2C_3(Data);
	I2C_Ack3();
	I2C_Stop3();
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=







//汉字点阵 16*16  阴码 顺向 逐列式
const unsigned char font_1616[1][32]=
{ //16*16/8=32


0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //空白不显示



	

};

const unsigned char  zm8x16_index[]="0123456789: |-+";//字串索引
const unsigned char  zm8x16_Table[][16]={
0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00,/*"0",0*/

0x00,0x00,0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,/*"1",1*/

0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x10,0x84,0x0F,0x0C,0x00,0x00,/*"2",2*/

0x00,0x00,0x0C,0x18,0x10,0x04,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00,/*"3",3*/

0x00,0x00,0x00,0x60,0x01,0xA0,0x02,0x24,0x0C,0x24,0x1F,0xFC,0x00,0x24,0x00,0x24,/*"4",4*/

0x00,0x00,0x1F,0x98,0x11,0x04,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00,/*"5",5*/

0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x09,0x04,0x00,0xF8,0x00,0x00,/*"6",6*/

0x00,0x00,0x18,0x00,0x10,0x00,0x10,0x7C,0x11,0x80,0x16,0x00,0x18,0x00,0x00,0x00,/*"7",7*/

0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00,/*"8",8*/

0x00,0x00,0x0F,0x80,0x10,0x48,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00,/*"9",9*/

0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,/*":",10*/

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",11*/

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,/*"|",12*/

0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,/*"-",13*/

0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x07,0xF0,0x00,0x80,0x00,0x80,0x00,0x80,/*"+",14*/
};
const unsigned char  zm16x16_index[]="欢迎使用密码锁请输入密码";//字串索引
const unsigned char  zm16x16_Table[][32]={

0x20,0x08,0x24,0x10,0x22,0x60,0x21,0x80,0x26,0x41,0x39,0x32,0x02,0x04,0x0C,0x18,
0xF0,0x60,0x13,0x80,0x10,0x60,0x10,0x18,0x14,0x04,0x18,0x02,0x00,0x01,0x00,0x00,/*"?",0*/

0x02,0x00,0x02,0x02,0x42,0x04,0x33,0xF8,0x00,0x04,0x00,0x02,0x3F,0xF2,0x20,0x22,
0x40,0x42,0x00,0x02,0x3F,0xFE,0x20,0x42,0x20,0x22,0x3F,0xC2,0x00,0x02,0x00,0x00,/*"?",1*/

0x01,0x00,0x06,0x00,0x1F,0xFF,0xE0,0x00,0x20,0x01,0x27,0x81,0x24,0xA2,0x24,0x94,
0x24,0x88,0xFF,0xF4,0x24,0x82,0x24,0x82,0x24,0x81,0x27,0x81,0x20,0x01,0x00,0x00,/*"?",2*/

0x00,0x01,0x00,0x06,0x7F,0xF8,0x44,0x40,0x44,0x40,0x44,0x40,0x44,0x40,0x7F,0xFE,
0x44,0x40,0x44,0x40,0x44,0x42,0x44,0x41,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,/*"?",3*/

0x08,0x40,0x31,0x40,0x22,0x5E,0x20,0x82,0x27,0x82,0x20,0xC2,0xA9,0x42,0x65,0x7E,
0x22,0x42,0x24,0x42,0x28,0x42,0x21,0xC2,0x22,0x1F,0x29,0x00,0x30,0x00,0x00,0x00,/*"?",4*/

0x20,0x40,0x21,0x80,0x27,0xFE,0x3A,0x08,0x22,0x08,0x23,0xFC,0x00,0x00,0x40,0x10,
0x4F,0x10,0x41,0x10,0x41,0x10,0x41,0x12,0x7F,0x11,0x01,0x02,0x01,0xFC,0x00,0x00,/*"?",5*/

0x04,0x80,0x08,0x80,0x34,0x80,0xE7,0xFE,0x24,0x84,0x24,0x88,0x00,0x01,0x47,0xF2,
0x34,0x04,0x04,0x08,0xFD,0xF0,0x04,0x08,0x14,0x04,0x67,0xF2,0x00,0x01,0x00,0x00,/*"?",6*/

0x02,0x00,0x42,0x00,0x33,0xFE,0x00,0x04,0x00,0x08,0x22,0x00,0x2A,0xFF,0x2A,0xA8,
0x2A,0xA8,0xFE,0xA8,0x2A,0xAA,0x2A,0xA9,0x2A,0xFE,0x22,0x00,0x02,0x00,0x00,0x00,/*"?",7*/

0x11,0x90,0x16,0x98,0xF8,0x90,0x13,0xFF,0x10,0xA0,0x08,0x00,0x13,0xFF,0x2A,0x48,
0x4A,0x49,0x8B,0xFF,0x48,0x00,0x29,0xFA,0x10,0x01,0x0B,0xFE,0x08,0x00,0x00,0x00,/*"?",8*/

0x00,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x30,0x80,0xC0,0x47,0x00,0x38,0x00,
0x07,0x00,0x00,0xC0,0x00,0x30,0x00,0x0C,0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x00,/*"?",9*/

0x08,0x40,0x31,0x40,0x22,0x5E,0x20,0x82,0x27,0x82,0x20,0xC2,0xA9,0x42,0x65,0x7E,
0x22,0x42,0x24,0x42,0x28,0x42,0x21,0xC2,0x22,0x1F,0x29,0x00,0x30,0x00,0x00,0x00,/*"?",10*/

0x20,0x40,0x21,0x80,0x27,0xFE,0x3A,0x08,0x22,0x08,0x23,0xFC,0x00,0x00,0x40,0x10,
0x4F,0x10,0x41,0x10,0x41,0x10,0x41,0x12,0x7F,0x11,0x01,0x02,0x01,0xFC,0x00,0x00,/*"?",11*/
			
};

////画点 
////x:0~127
////y:0~63
////t:1 填充 0,清空				   
//void OLED_DrawPoint(u8 x,u8 y,u8 t)
//{
//	u8 pos,bx,temp=0;
//	if(x>127||y>63)return;//超出范围了.
//	pos=7-y/8;
//	bx=y%8;
//	temp=1<<(7-bx);
//	if(t)OLED_GRAM[x][pos]|=temp;
//	else OLED_GRAM[x][pos]&=~temp;	    
//}


	
	


void	OLED_Init3(void)
{
	
  GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  ,ENABLE);
 

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8|GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);  
  
 
	delay_ms(300);
	
	
//		RES3=0;
//		//uDelay(2);
//		RES3=1;
//		//internal setting


		Write_Command3(0xae);	//--turn off oled panel

		Write_Command3(0x00);	//--set low column address
		Write_Command3(0x10);	//--set high column address

		Write_Command3(0x40);	//--set start line address

		Write_Command3(0xb0);	//--set page address

		Write_Command3(0x81);	//--set contrast control register
		Write_Command3(0xff);

		Write_Command3(0xa1);	//--set segment re-map 127 to 0   a0:0 to seg127
		Write_Command3(0xa6);	//--set normal display


		//切换显示角度 上下颠倒显示
		//Write_Command3(0xc0);	//--set com(N-1)to com0  c0:com0 to com(N-1)
		
		//切换显示角度
		Write_Command3(0xc0);	//--set com(N-1)to com0  c0:com0 to com(N-1)

		Write_Command3(0xa8);	//--set multiples ratio(1to64)
		Write_Command3(0x3f);	//--1/64 duty

		Write_Command3(0xd3);	//--set display offset
		Write_Command3(0x00);	//--not offset

		Write_Command3(0xd5);	//--set display clock divide ratio/oscillator frequency
		Write_Command3(0x80);	//--set divide ratio

		Write_Command3(0xd9);	//--set pre-charge period
		Write_Command3(0xf1);

		Write_Command3(0xda);	//--set com pins hardware configuration
		Write_Command3(0x12);

		Write_Command3(0xdb);	//--set vcomh
		Write_Command3(0x40);

		Write_Command3(0x8d);	//--set chare pump enable/disable
		Write_Command3(0x14);	//--set(0x10) disable
		//Write_Command3(0x10);	//--set(0x10) disable
		Write_Command3(0xaf);	//--turn on oled panel
		//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=void 	LCD_Init(void)
		
		OLED_Clear();
		

}



//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  
void OLED_Clear(void)  
{  
	u8 i,n;  
	for(i=0;i<8;i++)for(n=0;n<128;n++)OLED_GRAM[n][i]=0X00;  
	//OLED_Refresh_Gram();//更新显示
}

//更新显存到LCD		 
void OLED_Refresh_Gram(void)
{
	u8 j,n;
	
//	for(i=0;i<8;i++)  
//	{  
//		OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）
//		OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置―列低地址
//		OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置―列高地址   
//		
//	}  



	for(j=0;j<8;j++)
	{
		Write_Command3(0x22);//--set page1
		Write_Command3(j);//--set start page
		Write_Command3(0x07);//--set end page

		
		for(n=0;n<128;n++)Write_Data3(OLED_GRAM[n][j]); 
		
	}
	
}


//画点 
//x:0~127
//y:0~63
//t:1 填充 0,清空				   
void OLED_DrawPoint(u8 x,u8 y,u8 t)
{
	u8 pos,bx,temp=0;
	if(x>127||y>63)return;//超出范围了.
	pos=7-y/8;
	bx=y%8;
	temp=1<<(7-bx);
	if(t)OLED_GRAM[x][pos]|=temp;
	else OLED_GRAM[x][pos]&=~temp;	    
}



void OLED_ShowGBK(u8 x, u8 y,  u8 num, u8 size,u8 mode)
{
    u8 temp,t,t1;
    u8 y0=y;
	//u8 size = 16;
    u8 csize=(size/8 + ((size%8)?1:0)) * size;     //得到字体一个字符对应点阵集所占的字节数
              
    for(t=0;t<csize;t++)
    {  
		   if(size==16) temp = font_1616[num][t];    //调用1616字体
//      else if(size==24)temp=asc2_2412[chr][t];    //调用2412字体
        else return;                                //没有的字库
		   for(t1=0;t1<8;t1++)
        {
            if(temp&0x80)OLED_DrawPoint(x,y,mode);
            else OLED_DrawPoint(x,y,!mode);
            temp<<=1;
            y++;
            if((y-y0)==size)
            {
                y=y0;
                x++;
                break;
            }
        }    
    } 	

	}

	
	
	
	//在指定位置显示一个字符,包括部分字符
//x:0~127
//y:0~63
//mode:0,反白显示;1,正常显示				 
//size:选择字体 16/12 
void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)
{      			    
	u8 temp,t,t1;
	u8 y0=y;
	chr=chr-' ';//得到偏移后的值				   
    for(t=0;t<size;t++)
    {   
		if(size==12)temp=asc2_1206[chr][t];  //调用1206字体
		else temp=asc2_1608[chr][t];		 //调用1608字体 	                          
        for(t1=0;t1<8;t1++)
		{
			if(temp&0x80)OLED_DrawPoint(x,y,mode);
			else OLED_DrawPoint(x,y,!mode);
			temp<<=1;
			y++;
			if((y-y0)==size)
			{
				y=y0;
				x++;
				break;
			}
		}  	 
    }          
}



//显示字符串
//x,y:起点坐标  
//*p:字符串起始地址
//用16字体
void OLED_ShowString(u8 x,u8 y,const u8 *p)
{
#define MAX_CHAR_POSX 122
#define MAX_CHAR_POSY 58          
    while(*p!='\0')
    {       
        if(x>MAX_CHAR_POSX){x=0;y+=16;}
        if(y>MAX_CHAR_POSY){y=x=0;OLED_Clear();}
        OLED_ShowChar(x,y,*p,16,1);	 
        x+=8;
        p++;
    }  
}


/* 返回一个8*16字符索引位置 */					
unsigned char enN(unsigned char *s){
	unsigned char i;
	for(i=0;zm8x16_index[i]!=0;i++)if(zm8x16_index[i]==s[0])break;
	return i;	
}
/* 返回一个16*16字符索引位置 */
unsigned char cnN(unsigned char *s){
	unsigned char i;
	for(i=0;zm16x16_index[i]!=0;i+=2)
		if(zm16x16_index[i]==*s&&zm16x16_index[i+1]==*(s+1))break ;
	return i/2;
}




void OLED_ShowStr_ENCH(u8 x, u8 y,unsigned char *s,u8 mode)
{
	 u8 temp,t,t1,value;
   u8 y0=y;
	 unsigned char i;
	 for(i=0;s[i]!=0;i++){
	 	if(s[i]<0x80){ 	//英文
			value=enN(&s[i]);
			
			for(t=0;t<16;t++)
			{  
				  temp = zm8x16_Table[value][t];    //调用1616字体

					for(t1=0;t1<8;t1++)
					{
							if(temp&0x80)OLED_DrawPoint(x,y,mode);
							else OLED_DrawPoint(x,y,!mode);
							temp<<=1;
							y++;
							if((y-y0)==16)
							{
									y=y0;
									x++;
									break;
							}
					}    
			} 	
			//x=x+8;	
		}else{			//中文
			value=cnN(&s[i]);
			for(t=0;t<32;t++)
			{  
				  temp = zm16x16_Table[value][t];    //调用1616字体

					for(t1=0;t1<8;t1++)
					{
							if(temp&0x80)OLED_DrawPoint(x,y,mode);
							else OLED_DrawPoint(x,y,!mode);
							temp<<=1;
							y++;
							if((y-y0)==16)
							{
									y=y0;
									x++;
									break;
							}
					}    
			}
			//中文两个字节，需要加1
			i+=1;			
		}//中文
		
	}		
}


//m^n函数
u32 oled_pow(u8 m,u8 n)
{
	u32 result=1;	 
	while(n--)result*=m;    
	return result;
}		
//显示2个数字
//x,y :起点坐标	 
//len :数字的位数
//size:字体大小
//mode:模式	0,填充模式;1,叠加模式
//num:数值(0~4294967295);	 		  
void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)
{         	
	u8 t,temp;
	u8 enshow=0;						   
	for(t=0;t<len;t++)
	{
		temp=(num/oled_pow(10,len-t-1))%10;
		if(enshow==0&&t<(len-1))
		{
			if(temp==0)
			{
				OLED_ShowChar(x+(size/2)*t,y,' ',16,1);
				continue;
			}else enshow=1; 
		 	 
		}
	 	OLED_ShowChar(x+(size/2)*t,y,temp+'0',16,1); 
	}
} 













